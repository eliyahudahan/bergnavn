// backend/static/js/maritime.js - BergNavn Maritime Real-time Dashboard
// Professional maritime operations platform with multiple data sources

class MaritimeWeatherService {
    constructor() {
        this.USER_AGENT = 'BergNavnMaritime/2.0 (framgangsrik747@gmail.com)';
        this.CACHE_DURATION = 10 * 60 * 1000; // 10 minutes cache
        this.cache = new Map();
        this.isOnline = true;
        this.currentSource = 'Backend API';
    }

    /**
     * Fetch weather data with multiple fallback sources
     * @param {number} latitude - Geographic latitude
     * @param {number} longitude - Geographic longitude  
     * @param {string} locationName - Human-readable location name
     * @returns {Promise<Object>} Weather data object
     */
    async getMaritimeWeather(latitude, longitude, locationName) {
        const cacheKey = `${latitude},${longitude}`;
        
        // Check cache first for performance optimization
        if (this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < this.CACHE_DURATION) {
                return cached.data;
            }
        }

        try {
            // Primary data source - Backend API (OpenWeather)
            let weatherData = await this.fetchFromBackendAPI(latitude, longitude, locationName);
            this.currentSource = 'Backend API';
            
            // Secondary fallback - Direct MET Norway API
            if (!weatherData) {
                weatherData = await this.fetchFromMetNorway(latitude, longitude);
                this.currentSource = 'MET Norway';
            }
            
            const enrichedData = {
                ...weatherData,
                location: locationName,
                timestamp: new Date().toISOString(),
                source: this.currentSource
            };
            
            // Update cache with fresh data
            this.cache.set(cacheKey, {
                data: enrichedData,
                timestamp: Date.now()
            });
            
            this.isOnline = true;
            return enrichedData;
            
        } catch (error) {
            console.warn(`All weather APIs failed for ${locationName}:`, error);
            this.isOnline = false;
            this.currentSource = 'Mock Data';
            return this.getMockWeatherData(latitude, longitude, locationName);
        }
    }

    /**
     * Fetch weather data from backend API (primary source)
     * @param {number} lat - Latitude coordinate
     * @param {number} lon - Longitude coordinate
     * @param {string} locationName - Location name for context
     * @returns {Promise<Object>} Parsed weather data
     */
    async fetchFromBackendAPI(lat, lon, locationName) {
        const url = `/maritime/api/weather?lat=${lat}&lon=${lon}&location=${encodeURIComponent(locationName)}`;
        
        try {
            const response = await fetch(url, {
                timeout: 10000
            });

            if (!response.ok) {
                throw new Error(`Backend API error: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.status === 'success') {
                return this.parseBackendWeatherResponse(data.data);
            } else {
                throw new Error(data.message || 'Backend API returned error');
            }
        } catch (error) {
            console.warn('Backend weather API failed, trying MET Norway...');
            return null;
        }
    }

    /**
     * Parse backend weather API response
     * @param {Object} weatherData - Weather data from backend API
     * @returns {Object} Structured weather information
     */
    parseBackendWeatherResponse(weatherData) {
        return {
            temperature: weatherData.temperature,
            windSpeed: weatherData.wind_speed,
            windDirection: weatherData.wind_direction || 0,
            windGust: weatherData.wind_gust || weatherData.wind_speed * 1.3,
            pressure: weatherData.pressure,
            humidity: weatherData.humidity,
            cloudCover: weatherData.cloud_cover || 50,
            condition: { 
                text: weatherData.condition, 
                icon: weatherData.icon 
            }
        };
    }

    /**
     * Fetch live data from MET Norway API (fallback source)
     * @param {number} lat - Latitude coordinate
     * @param {number} lon - Longitude coordinate
     * @returns {Promise<Object>} Parsed weather data
     */
    async fetchFromMetNorway(lat, lon) {
        const url = `https://api.met.no/weatherapi/locationforecast/2.0/complete?lat=${lat}&lon=${lon}`;
        
        try {
            const response = await fetch(url, {
                headers: {
                    'User-Agent': this.USER_AGENT,
                    'Accept': 'application/json'
                },
                timeout: 10000
            });

            if (!response.ok) {
                throw new Error(`MET Norway API error: ${response.status}`);
            }

            const data = await response.json();
            return this.parseMETNorwayResponse(data);
        } catch (error) {
            console.warn('MET Norway API failed, using mock data...');
            throw error;
        }
    }

    /**
     * Parse MET Norway API response into structured data
     * @param {Object} apiData - Raw API response from MET Norway
     * @returns {Object} Structured weather information
     */
    parseMETNorwayResponse(apiData) {
        const current = apiData.properties.timeseries[0];
        const details = current.data.instant.details;
        
        return {
            temperature: details.air_temperature,
            windSpeed: details.wind_speed,
            windDirection: details.wind_from_direction,
            windGust: details.wind_speed_of_gust,
            pressure: details.air_pressure_at_sea_level,
            humidity: details.relative_humidity,
            cloudCover: details.cloud_area_fraction,
            condition: this.mapMETNorwayCondition(current.data.next_1_hours?.summary.symbol_code)
        };
    }

    /**
     * Map MET Norway condition codes to readable format with icons
     * @param {string} conditionCode - MET Norway condition code
     * @returns {Object} Mapped condition with text and icon
     */
    mapMETNorwayCondition(conditionCode) {
        const conditions = {
            'clearsky': { text: 'Clear Sky', icon: '☀️' },
            'fair': { text: 'Fair', icon: '🌤️' },
            'partlycloudy': { text: 'Partly Cloudy', icon: '⛅' },
            'cloudy': { text: 'Cloudy', icon: '☁️' },
            'lightrain': { text: 'Light Rain', icon: '🌦️' },
            'rain': { text: 'Rain', icon: '🌧️' },
            'heavyrain': { text: 'Heavy Rain', icon: '⛈️' },
            'lightsnow': { text: 'Light Snow', icon: '🌨️' },
            'snow': { text: 'Snow', icon: '❄️' },
            'fog': { text: 'Fog', icon: '🌫️' }
        };
        
        return conditions[conditionCode] || { text: conditionCode, icon: '🌡️' };
    }

    /**
     * Generate mock data for offline fallback mode
     * @param {number} lat - Latitude for realistic data generation
     * @param {number} lon - Longitude for realistic data generation  
     * @param {string} locationName - Location name for context
     * @returns {Object} Mock weather data
     */
    getMockWeatherData(lat, lon, locationName) {
        const baseTemp = 8 + (lat - 58) * 0.5; // Temperature varies with latitude
        const baseWind = 3 + Math.random() * 12; // Realistic wind speeds
        
        return {
            temperature: Math.round((baseTemp + (Math.random() * 6 - 3)) * 10) / 10,
            windSpeed: Math.round(baseWind * 10) / 10,
            windDirection: Math.floor(Math.random() * 360),
            windGust: Math.round((baseWind * 1.3) * 10) / 10,
            pressure: 1000 + Math.floor(Math.random() * 30),
            humidity: 65 + Math.floor(Math.random() * 25),
            cloudCover: Math.floor(Math.random() * 100),
            condition: { text: 'Fair', icon: '🌤️' },
            location: locationName,
            timestamp: new Date().toISOString(),
            source: 'Mock Data (Offline)'
        };
    }
}

/**
 * Maritime Route Manager for Kristiansand-Oslo route operations
 * Handles route data and ETA calculations
 */
class MaritimeRouteManager {
    constructor() {
        this.routePoints = [
            { name: 'Kristiansand', lat: 58.1467, lon: 8.0980, type: 'port' },
            { name: 'Oksøy Lighthouse', lat: 58.0667, lon: 8.0500, type: 'navigation' },
            { name: 'Jomfruland', lat: 58.8650, lon: 9.5833, type: 'navigation' },
            { name: 'Færder Lighthouse', lat: 59.0275, lon: 10.5242, type: 'navigation' },
            { name: 'Oslo Fjord', lat: 59.9115, lon: 10.7570, type: 'port' }
        ];
    }

    /**
     * Get important weather points along the maritime route
     * @returns {Array} Filtered route points for weather monitoring
     */
    getWeatherPoints() {
        return this.routePoints.filter(point => 
            point.type === 'port' || point.name.includes('Lighthouse')
        );
    }

    /**
     * Calculate ETA based on weather conditions and route parameters
     * @param {Array} weatherConditions - Weather data along the route
     * @returns {Object} ETA calculations with base and adjusted values
     */
    calculateETA(weatherConditions) {
        const baseDistance = 250; // nautical miles - Kristiansand to Oslo
        const baseSpeed = 12; // knots - typical vessel speed
        const baseETA = baseDistance / baseSpeed; // ~20.8 hours
        
        // Weather impact model for ETA adjustment
        let weatherFactor = 1.0;
        weatherConditions.forEach(weather => {
            // High winds increase travel time
            if (weather.windSpeed > 15) weatherFactor += 0.1;
            // Low temperatures can affect vessel performance
            if (weather.temperature < 2) weatherFactor += 0.05;
        });
        
        const adjustedETA = baseETA * weatherFactor;
        return {
            base: Math.round(baseETA * 10) / 10,
            adjusted: Math.round(adjustedETA * 10) / 10,
            unit: 'hours'
        };
    }
}

/**
 * Main Maritime Dashboard Controller
 * Orchestrates weather data, route management, and UI updates
 */
class MaritimeDashboard {
    constructor() {
        this.weatherService = new MaritimeWeatherService();
        this.routeManager = new MaritimeRouteManager();
        this.updateInterval = null;
    }

    /**
     * Initialize the maritime dashboard components
     */
    async initialize() {
        console.log('🚢 Initializing BergNavn Maritime Dashboard...');
        
        await this.loadWeatherData();
        this.setupAutoRefresh();
        this.setupEventListeners();
        
        this.updateStatusDisplay();
    }

    /**
     * Load and display weather data for all route points
     */
    async loadWeatherData() {
        const weatherPoints = this.routeManager.getWeatherPoints();
        const weatherContainer = document.getElementById('weather-data');
        
        if (!weatherContainer) {
            console.error('Weather container element not found');
            return;
        }

        // Show loading state during data fetch
        weatherContainer.innerHTML = `
            <div class="col-12 text-center">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading maritime weather data...</span>
                </div>
                <p class="mt-2">Loading real-time weather data...</p>
            </div>
        `;

        try {
            // Fetch weather data for all route points concurrently
            const weatherPromises = weatherPoints.map(point =>
                this.weatherService.getMaritimeWeather(point.lat, point.lon, point.name)
            );
            
            const weatherResults = await Promise.all(weatherPromises);
            this.displayWeatherData(weatherResults);
            await this.updateRouteETA(); // Fetch ETA from backend
            
        } catch (error) {
            console.error('Failed to load weather data:', error);
            this.displayError('Failed to load weather data. Using offline mode.');
        }
    }

    /**
     * Display weather data in the dashboard UI
     * @param {Array} weatherData - Array of weather data objects
     */
    displayWeatherData(weatherData) {
        const weatherContainer = document.getElementById('weather-data');
        
        const weatherHTML = weatherData.map(weather => `
            <div class="col-md-3 mb-3">
                <div class="card h-100">
                    <div class="card-body text-center">
                        <h6 class="card-title">${weather.location}</h6>
                        <div class="weather-icon display-6">${weather.condition.icon}</div>
                        <div class="temperature h5">${Math.round(weather.temperature)}°C</div>
                        <div class="weather-details">
                            <small class="text-muted">
                                💨 ${Math.round(weather.windSpeed)} m/s<br>
                                💧 ${weather.humidity}% humidity<br>
                                📊 ${weather.pressure} hPa
                            </small>
                        </div>
                        <div class="weather-source">
                            <small class="text-info">Source: ${weather.source}</small>
                        </div>
                    </div>
                </div>
            </div>
        `).join('');

        weatherContainer.innerHTML = weatherHTML;
    }

    /**
     * Update route ETA display from backend API
     */
    async updateRouteETA() {
        try {
            const response = await fetch('/maritime/api/route/eta');
            const data = await response.json();
            
            if (data.status === 'success') {
                const etaDisplay = document.getElementById('route-eta-display');
                if (etaDisplay) {
                    etaDisplay.innerHTML = `
                        Base: ${data.data.base_eta}h | 
                        Adjusted: ${data.data.adjusted_eta}h
                        <br><small>Weather impact: +${data.data.weather_impact}%</small>
                    `;
                }
            }
        } catch (error) {
            console.warn('Failed to fetch ETA data:', error);
        }
    }

    /**
     * Setup auto-refresh mechanism for weather data
     */
    setupAutoRefresh() {
        // Refresh every 5 minutes
        this.updateInterval = setInterval(() => {
            this.loadWeatherData();
        }, 300000);
    }

    /**
     * Setup event listeners for user interactions
     */
    setupEventListeners() {
        const refreshButton = document.getElementById('refresh-weather');
        if (refreshButton) {
            refreshButton.addEventListener('click', () => {
                this.loadWeatherData();
            });
        }
    }

    /**
     * Update API status display
     */
    updateStatusDisplay() {
        const statusElement = document.getElementById('api-status');
        if (statusElement) {
            if (this.weatherService.isOnline) {
                statusElement.className = 'badge bg-success';
                statusElement.textContent = `Online (${this.weatherService.currentSource})`;
            } else {
                statusElement.className = 'badge bg-warning';
                statusElement.textContent = 'Offline (Mock Data)';
            }
        }
    }

    /**
     * Display error message to user
     * @param {string} message - Error message to display
     */
    displayError(message) {
        const weatherContainer = document.getElementById('weather-data');
        if (weatherContainer) {
            weatherContainer.innerHTML = `
                <div class="col-12">
                    <div class="alert alert-warning" role="alert">
                        <strong>Warning:</strong> ${message}
                    </div>
                </div>
            `;
        }
    }
}

// Initialize dashboard when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    const dashboard = new MaritimeDashboard();
    dashboard.initialize();
});