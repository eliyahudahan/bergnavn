# backend/routes/maritime_routes.py
"""
Maritime routes for the BergNavn Maritime Dashboard.
FIXED: Added empirical verification support with proper variable passing.
ENHANCED: Route deduplication with accurate counts.
REAL-TIME: Weather and AIS endpoints with proper fallbacks.
"""

import logging
from flask import Blueprint, jsonify, request, render_template, current_app
from typing import Dict, List, Any
from datetime import datetime, timedelta
import math

logger = logging.getLogger(__name__)

# Create blueprint
maritime_bp = Blueprint('maritime', __name__, url_prefix='/maritime')

# Initialize alerts service with fallback
ALERTS_SERVICE_AVAILABLE = False

try:
    from backend.services.alerts_service import maritime_alerts_service
    ALERTS_SERVICE_AVAILABLE = True
    logger.info("✅ Alerts service available")
except ImportError:
    logger.warning("⚠️ Alerts service not available, using fallback")
    
    class FallbackAlertsService:
        def __init__(self):
            self._alert_cache = {}
            self._cache_duration = timedelta(minutes=1)
        
        def generate_vessel_alerts(self, vessel, context):
            return []
        
        def get_service_status(self):
            return {
                'service': 'FallbackAlertsService',
                'status': 'active',
                'fallback': True
            }
    
    maritime_alerts_service = FallbackAlertsService()

# Try to import simulation
try:
    from backend.simulation.bergen_simulator import bergen_simulator
    SIMULATION_AVAILABLE = True
    logger.info("✅ Simulation available")
except ImportError:
    SIMULATION_AVAILABLE = False
    logger.warning("⚠️ Simulation not available")

@maritime_bp.route('/dashboard')
def maritime_dashboard():
    """
    Render the main maritime dashboard.
    Shows unique RTZ routes after deduplication with empirical verification.
    """
    try:
        # Get AIS service status
        ais_status = "offline"
        ais_vessel_count = 0
        
        if hasattr(current_app, 'ais_service'):
            try:
                status = current_app.ais_service.get_service_status()
                ais_status = "online" if status.get('operational_status', {}).get('running', False) else "offline"
                ais_vessel_count = status.get('data_metrics', {}).get('active_vessels', 0)
            except Exception as e:
                logger.warning(f"Could not get AIS status: {e}")
        
        # Get empirically verified RTZ routes
        routes_data = []
        cities_with_routes = set()
        route_count = 0
        verification_hash = ""
        methodology = "empirical_deduplication"
        
        try:
            # Use RouteService for empirically verified routes
            from backend.services.route_service import route_service
            
            # Get empirical data
            empirical_data = route_service.get_empirical_count()
            routes_data = empirical_data.get('routes', [])
            route_count = empirical_data.get('empirical_count', 0)
            verification_hash = empirical_data.get('verification_hash', '')
            methodology = empirical_data.get('methodology', 'empirical_deduplication')
            
            # Extract city information
            for route in routes_data:
                if source_city := route.get('source_city'):
                    cities_with_routes.add(source_city.title())
            
            logger.info(f"✅ Loaded {route_count} empirically verified RTZ routes")
            
        except ImportError as e:
            logger.error(f"RouteService import error: {e}")
            # Fallback to rtz_parser
            try:
                from backend.services.rtz_parser import discover_rtz_files
                routes_data = discover_rtz_files(enhanced=True)
                route_count = len(routes_data)
                verification_hash = "fallback_no_verification"
                methodology = "rtz_parser_fallback"
                
                for route in routes_data:
                    if city := route.get('source_city'):
                        cities_with_routes.add(city.title())
                logger.warning(f"⚠️ Using rtz_parser fallback: {route_count} routes")
            except Exception as e2:
                logger.error(f"Could not discover RTZ files: {e2}")
                routes_data = []
        
        # Calculate statistics
        total_distance = sum(route.get('total_distance_nm', 0) for route in routes_data)
        waypoint_count = sum(route.get('waypoint_count', 0) for route in routes_data)
        active_ports_count = len(cities_with_routes)
        
        # Extract visual properties for JavaScript
        route_colors = []
        if routes_data:
            for route in routes_data:
                visual = route.get('visual_properties', {})
                route_colors.append({
                    'name': route.get('clean_name', route.get('route_name', 'Unknown')),
                    'color': visual.get('color', '#3498db'),
                    'start': route.get('start_point', {}),
                    'end': route.get('end_point', {})
                })
        
        # Prepare context with ALL required variables
        context = {
            'lang': request.args.get('lang', 'en'),
            'routes': routes_data,
            'route_count': route_count,
            'route_colors': route_colors,
            'cities_with_routes': sorted(list(cities_with_routes)),
            'unique_ports_count': active_ports_count,
            'ports_list': sorted(list(cities_with_routes)),
            'total_distance': total_distance,
            'waypoint_count': waypoint_count,
            'active_ports_count': active_ports_count,
            'ais_status': ais_status,
            'ais_vessel_count': ais_vessel_count,
            'timestamp': datetime.now().isoformat(),
            'empirical_verification': {
                'methodology': methodology,
                'verification_hash': verification_hash,
                'status': 'verified' if verification_hash else 'unverified'
            }
        }
        
        return render_template(
            'maritime_split/dashboard_base.html',
            **context
        )
        
    except Exception as e:
        logger.error(f"Error rendering maritime dashboard: {e}", exc_info=True)
        # Fallback context to avoid template errors
        fallback_context = {
            'lang': request.args.get('lang', 'en'),
            'routes': [],
            'route_count': 0,
            'route_colors': [],
            'cities_with_routes': [],
            'unique_ports_count': 0,
            'ports_list': [],
            'total_distance': 0,
            'waypoint_count': 0,
            'active_ports_count': 0,
            'ais_status': 'offline',
            'ais_vessel_count': 0,
            'timestamp': datetime.now().isoformat(),
            'empirical_verification': {
                'methodology': 'error',
                'verification_hash': '',
                'status': 'error'
            }
        }
        
        return render_template(
            'maritime_split/dashboard_base.html',
            **fallback_context
        ), 500

@maritime_bp.route('/simulation')
def simulation_dashboard():
    """
    Render the simulation dashboard for operator training.
    """
    try:
        # Get basic data
        routes_data = []
        try:
            from backend.services.route_service import route_service
            empirical_data = route_service.get_empirical_count()
            routes_data = empirical_data.get('routes', [])
        except ImportError:
            pass
        
        # Get simulation data if available
        simulation_data = {}
        if SIMULATION_AVAILABLE:
            try:
                simulation_data = bergen_simulator.to_dict()
            except:
                simulation_data = {'status': 'simulation_not_available'}
        
        return render_template(
            'maritime_split/realtime_simulation.html',
            routes=routes_data,
            simulation=simulation_data,
            simulation_available=SIMULATION_AVAILABLE,
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error rendering simulation dashboard: {e}")
        return render_template(
            'error.html',
            error_message="Could not load simulation dashboard",
            error_details=str(e)
        ), 500

@maritime_bp.route('/api/health')
def health_check():
    """
    Health check endpoint for maritime services.
    """
    try:
        status = {
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'services': {}
        }
        
        # Check AIS service
        if hasattr(current_app, 'ais_service'):
            try:
                ais_status = current_app.ais_service.get_service_status()
                status['services']['ais'] = {
                    'status': 'online',
                    'mode': ais_status.get('operational_status', {}).get('mode', 'unknown'),
                    'vessels': ais_status.get('data_metrics', {}).get('active_vessels', 0)
                }
            except Exception as e:
                status['services']['ais'] = {
                    'status': 'error',
                    'error': str(e)
                }
        else:
            status['services']['ais'] = {
                'status': 'offline',
                'error': 'AIS service not initialized'
            }
        
        # Check RTZ routes with empirical verification
        try:
            from backend.services.route_service import route_service
            empirical_data = route_service.get_empirical_count()
            route_stats = route_service.get_route_statistics()
            
            status['services']['rtz_routes'] = {
                'status': 'available',
                'empirical_count': empirical_data.get('empirical_count', 0),
                'ports_count': empirical_data.get('ports_count', 0),
                'verification_hash': empirical_data.get('verification_hash', '')[:16] + '...',
                'methodology': empirical_data.get('methodology', 'unknown')
            }
        except Exception as e:
            status['services']['rtz_routes'] = {
                'status': 'error',
                'error': str(e)
            }
        
        # Check overall health
        all_healthy = all(
            service['status'] in ['online', 'available', 'healthy'] 
            for service in status['services'].values()
        )
        
        status['overall'] = 'healthy' if all_healthy else 'degraded'
        
        return jsonify(status)
        
    except Exception as e:
        logger.error(f"Health check error: {e}")
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@maritime_bp.route('/api/empirical-routes')
def get_empirical_routes():
    """
    Get empirically verified routes.
    """
    try:
        from backend.services.route_service import route_service
        
        empirical_data = route_service.get_empirical_count()
        
        return jsonify({
            'success': True,
            'empirical_count': empirical_data.get('empirical_count', 0),
            'ports_count': empirical_data.get('ports_count', 0),
            'verification_hash': empirical_data.get('verification_hash', ''),
            'methodology': empirical_data.get('methodology', ''),
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Empirical routes API error: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@maritime_bp.route('/api/ais-data')
def get_ais_data():
    """
    Get real-time AIS vessel data.
    """
    try:
        if not hasattr(current_app, 'ais_service'):
            return jsonify({
                'error': 'AIS service not available',
                'timestamp': datetime.now().isoformat()
            }), 503
        
        # Try to get real-time data
        vessels = []
        try:
            if hasattr(current_app.ais_service, 'get_real_time_vessels'):
                vessels = current_app.ais_service.get_real_time_vessels()
            else:
                vessels = current_app.ais_service.get_latest_positions()
        except Exception as e:
            logger.warning(f"Could not get AIS data: {e}")
            vessels = []
        
        # Enhance with metadata
        enhanced_vessels = []
        for vessel in vessels:
            enhanced_vessel = vessel.copy()
            
            # Add Norwegian city proximity
            if 'lat' in vessel and 'lon' in vessel:
                enhanced_vessel['norwegian_proximity'] = _get_norwegian_city_proximity(
                    vessel['lat'], vessel['lon']
                )
            
            enhanced_vessels.append(enhanced_vessel)
        
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'vessel_count': len(enhanced_vessels),
            'vessels': enhanced_vessels
        })
        
    except Exception as e:
        logger.error(f"Error getting AIS data: {e}")
        return jsonify({
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@maritime_bp.route('/api/ais/realtime')
def get_realtime_ais():
    """
    Get real-time AIS data with forced refresh.
    """
    try:
        if not hasattr(current_app, 'ais_service'):
            return jsonify({
                'error': 'AIS service not available',
                'timestamp': datetime.now().isoformat()
            }), 503
        
        # Force refresh if supported
        vessels = []
        try:
            if hasattr(current_app.ais_service, 'get_real_time_vessels'):
                vessels = current_app.ais_service.get_real_time_vessels(force_refresh=True)
            else:
                vessels = current_app.ais_service.get_latest_positions()
        except Exception as e:
            logger.warning(f"Could not refresh AIS data: {e}")
            vessels = current_app.ais_service.get_latest_positions()
        
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'vessel_count': len(vessels),
            'vessels': vessels[:50]
        })
        
    except Exception as e:
        logger.error(f"Error in real-time AIS endpoint: {e}")
        return jsonify({
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@maritime_bp.route('/api/weather')
def get_weather():
    """
    Get current weather data for Norwegian coastal areas.
    """
    try:
        # Check if weather service is available
        if not hasattr(current_app, 'weather_service'):
            # Try to import weather service
            try:
                from backend.services.weather_service import weather_service
                current_app.weather_service = weather_service
            except ImportError:
                return jsonify({
                    'error': 'Weather service not available',
                    'timestamp': datetime.now().isoformat()
                }), 503
        
        # Get weather data
        weather_data = current_app.weather_service.get_current_weather()
        
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'weather': weather_data
        })
        
    except Exception as e:
        logger.error(f"Error getting weather data: {e}")
        return jsonify({
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@maritime_bp.route('/api/weather-dashboard')
def get_dashboard_weather():
    """
    Simplified weather endpoint for dashboard display.
    """
    try:
        # Check if weather service is available
        if not hasattr(current_app, 'weather_service'):
            # Try to import weather service
            try:
                from backend.services.weather_service import weather_service
                current_app.weather_service = weather_service
            except ImportError:
                logger.warning("Weather service not available, creating fallback")
                return _create_weather_fallback("Service not initialized")
        
        # Get weather data
        try:
            weather_data = current_app.weather_service.get_current_weather()
            
            # Ensure required fields exist
            processed_data = {
                'temperature_c': weather_data.get('temperature_c') or weather_data.get('temperature'),
                'wind_speed_ms': weather_data.get('wind_speed_ms') or weather_data.get('wind_speed'),
                'wind_direction_deg': weather_data.get('wind_direction_deg') or weather_data.get('wind_direction'),
                'wind_direction': weather_data.get('wind_direction') or _degrees_to_direction(
                    weather_data.get('wind_direction_deg') or weather_data.get('wind_direction')
                ),
                'city': weather_data.get('city') or 'Bergen',
                'timestamp': weather_data.get('timestamp') or datetime.now().isoformat()
            }
            
            # Add display values
            if processed_data['temperature_c'] is not None:
                processed_data['temperature_display'] = f"{processed_data['temperature_c']:.1f}°C"
            
            if processed_data['wind_speed_ms'] is not None:
                processed_data['wind_display'] = f"{processed_data['wind_speed_ms']:.1f} m/s"
            
            return jsonify(processed_data)
            
        except Exception as e:
            logger.error(f"Weather service error: {e}")
            return _create_weather_fallback(f"Weather service error: {e}")
        
    except Exception as e:
        logger.error(f"Dashboard weather endpoint error: {e}")
        return _create_weather_fallback(f"Endpoint error: {e}")

@maritime_bp.route('/api/rtz/routes')
def get_rtz_routes():
    """
    Get all available RTZ routes.
    """
    try:
        from backend.services.rtz_parser import discover_rtz_files
        routes_data = discover_rtz_files(enhanced=True)
        
        # Format for API response
        formatted_routes = []
        for route in routes_data:
            formatted_route = {
                'name': route.get('route_name', 'Unknown Route'),
                'origin': route.get('origin', 'Unknown'),
                'destination': route.get('destination', 'Unknown'),
                'total_distance_nm': route.get('total_distance_nm', 0),
                'waypoint_count': route.get('waypoint_count', 0),
                'source_city': route.get('source_city', 'Unknown'),
                'waypoints': route.get('waypoints', []),
                'visual_properties': route.get('visual_properties', {}),
                'start_point': route.get('start_point'),
                'end_point': route.get('end_point'),
                'parse_timestamp': route.get('parse_timestamp', datetime.now().isoformat())
            }
            formatted_routes.append(formatted_route)
        
        # Calculate statistics
        total_routes = len(formatted_routes)
        total_distance = sum(route['total_distance_nm'] for route in formatted_routes)
        total_waypoints = sum(route['waypoint_count'] for route in formatted_routes)
        
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'statistics': {
                'total_routes': total_routes,
                'total_distance_nm': round(total_distance, 1),
                'total_waypoints': total_waypoints
            },
            'routes': formatted_routes
        })
        
    except ImportError as e:
        logger.error(f"RTZ parser import error: {e}")
        return jsonify({
            'error': 'RTZ parser not available',
            'timestamp': datetime.now().isoformat()
        }), 503
    except Exception as e:
        logger.error(f"Error getting RTZ routes: {e}")
        return jsonify({
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@maritime_bp.route('/api/rtz/routes/deduplicated')
def get_deduplicated_rtz_routes():
    """
    Get deduplicated RTZ routes.
    """
    try:
        from backend.services.route_service import route_service
        
        # Get empirical data
        empirical_data = route_service.get_empirical_count()
        routes = empirical_data.get('routes', [])
        
        # Format for API response
        formatted_routes = []
        for route in routes:
            formatted_route = {
                'name': route.get('clean_name', route.get('name', 'Unknown Route')),
                'origin': route.get('origin', 'Unknown'),
                'destination': route.get('destination', 'Unknown'),
                'total_distance_nm': route.get('total_distance_nm', 0),
                'waypoint_count': route.get('waypoint_count', 0),
                'source_city': route.get('source_city', 'Unknown'),
                'waypoints': route.get('waypoints', []),
                'visual_properties': route.get('visual_properties', {}),
                'start_point': route.get('start_point'),
                'end_point': route.get('end_point'),
                'empirically_verified': route.get('empirically_verified', False),
                'verification_hash': route.get('verification_hash', ''),
                'parse_timestamp': route.get('parse_timestamp', datetime.now().isoformat())
            }
            formatted_routes.append(formatted_route)
        
        return jsonify({
            'success': True,
            'timestamp': datetime.now().isoformat(),
            'empirical_count': empirical_data.get('empirical_count', 0),
            'ports_count': empirical_data.get('ports_count', 0),
            'verification_hash': empirical_data.get('verification_hash', ''),
            'methodology': empirical_data.get('methodology', ''),
            'routes': formatted_routes
        })
        
    except Exception as e:
        logger.error(f"Error getting deduplicated RTZ routes: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'routes': []
        }), 500

@maritime_bp.route('/api/vessels/near/<city_name>')
def get_vessels_near_city(city_name: str):
    """
    Get vessels near a specific Norwegian city.
    """
    try:
        if not hasattr(current_app, 'ais_service'):
            return jsonify({
                'error': 'AIS service not available',
                'timestamp': datetime.now().isoformat()
            }), 503
        
        # Norwegian city coordinates
        norwegian_cities = {
            'bergen': {'lat': 60.3913, 'lon': 5.3221},
            'oslo': {'lat': 59.9139, 'lon': 10.7522},
            'stavanger': {'lat': 58.9699, 'lon': 5.7331},
            'trondheim': {'lat': 63.4305, 'lon': 10.3951},
            'alesund': {'lat': 62.4722, 'lon': 6.1497},
            'andalsnes': {'lat': 62.5675, 'lon': 7.6870},
            'kristiansand': {'lat': 58.1467, 'lon': 7.9958},
            'drammen': {'lat': 59.7441, 'lon': 10.2045},
            'sandefjord': {'lat': 59.1312, 'lon': 10.2167},
            'flekkefjord': {'lat': 58.2970, 'lon': 6.6605}
        }
        
        city_name_lower = city_name.lower()
        if city_name_lower not in norwegian_cities:
            return jsonify({
                'error': f'Unknown city: {city_name}',
                'timestamp': datetime.now().isoformat()
            }), 400
        
        city_data = norwegian_cities[city_name_lower]
        
        # Get vessels near city
        radius_km = request.args.get('radius', default=50, type=float)
        
        try:
            if hasattr(current_app.ais_service, 'get_vessels_near'):
                vessels = current_app.ais_service.get_vessels_near(
                    city_data['lat'], city_data['lon'], radius_km
                )
            else:
                # Fallback: filter from all vessels
                all_vessels = current_app.ais_service.get_latest_positions()
                vessels = []
                for vessel in all_vessels:
                    if 'lat' in vessel and 'lon' in vessel:
                        distance = _calculate_distance_km(
                            vessel['lat'], vessel['lon'],
                            city_data['lat'], city_data['lon']
                        )
                        if distance <= radius_km:
                            vessel_copy = vessel.copy()
                            vessel_copy['distance_km'] = round(distance, 2)
                            vessels.append(vessel_copy)
        except Exception as e:
            logger.warning(f"Could not get vessels near city: {e}")
            vessels = []
        
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'city': city_name_lower,
            'coordinates': city_data,
            'search_radius_km': radius_km,
            'vessel_count': len(vessels),
            'vessels': vessels
        })
        
    except Exception as e:
        logger.error(f"Error getting vessels near city: {e}")
        return jsonify({
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@maritime_bp.route('/api/alerts')
def get_alerts():
    """
    Get real-time maritime alerts.
    """
    try:
        # Get current timestamp
        current_time = datetime.now()
        
        # Check if alerts service is available
        if not ALERTS_SERVICE_AVAILABLE:
            return _create_alerts_fallback("Alerts service not initialized")
        
        # Try to get from cache
        cache_key = 'all_alerts'
        if (cache_key in maritime_alerts_service._alert_cache and 
            current_time - maritime_alerts_service._alert_cache[cache_key]['timestamp'] < 
            maritime_alerts_service._cache_duration):
            
            return jsonify(maritime_alerts_service._alert_cache[cache_key]['data'])
        
        # Get AIS data
        vessels = []
        try:
            if hasattr(current_app, 'ais_service'):
                vessels = current_app.ais_service.get_latest_positions()
        except Exception as e:
            logger.error(f"Error getting AIS data for alerts: {e}")
        
        # Generate alerts
        all_alerts = []
        for vessel in vessels[:20]:
            try:
                context = {'other_vessels': vessels}
                vessel_alerts = maritime_alerts_service.generate_vessel_alerts(vessel, context)
                all_alerts.extend(vessel_alerts)
            except Exception as e:
                continue
        
        # Count alerts by priority
        priority_counts = {
            'CRITICAL': len([a for a in all_alerts if a.get('priority') == 'CRITICAL']),
            'HIGH': len([a for a in all_alerts if a.get('priority') == 'HIGH']),
            'MEDIUM': len([a for a in all_alerts if a.get('priority') == 'MEDIUM']),
            'LOW': len([a for a in all_alerts if a.get('priority') == 'LOW'])
        }
        
        # Sort alerts
        priority_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
        all_alerts.sort(key=lambda x: priority_order.get(x.get('priority', 'LOW'), 4))
        
        # Prepare response
        response_data = {
            'timestamp': current_time.isoformat(),
            'total_alerts': len(all_alerts),
            'priority_counts': priority_counts,
            'alerts': all_alerts[:15],
            'service_status': maritime_alerts_service.get_service_status()
        }
        
        # Cache the results
        maritime_alerts_service._alert_cache[cache_key] = {
            'timestamp': current_time,
            'data': response_data
        }
        
        return jsonify(response_data)
        
    except Exception as e:
        logger.error(f"Error in alerts endpoint: {e}")
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'error': str(e),
            'alerts': [],
            'priority_counts': {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        }), 500

@maritime_bp.route('/api/system/status')
def system_status():
    """
    Get comprehensive system status.
    """
    try:
        status = {
            'timestamp': datetime.now().isoformat(),
            'system': 'BergNavn Maritime Dashboard',
            'version': '3.0',
            'services': {},
            'operational_metrics': {}
        }
        
        # AIS Service Status
        if hasattr(current_app, 'ais_service'):
            try:
                ais_status = current_app.ais_service.get_service_status()
                status['services']['ais'] = ais_status
            except Exception as e:
                status['services']['ais'] = {'error': str(e)}
        
        # RTZ Routes with Empirical Verification
        try:
            from backend.services.route_service import route_service
            empirical_data = route_service.get_empirical_count()
            route_stats = route_service.get_route_statistics()
            
            status['services']['rtz_routes'] = {
                'empirical_data': empirical_data,
                'statistics': route_stats
            }
        except Exception as e:
            status['services']['rtz_routes'] = {'error': str(e)}
        
        # Calculate operational metrics
        ais_vessels = status['services'].get('ais', {}).get('data_metrics', {}).get('active_vessels', 0)
        empirical_count = status['services'].get('rtz_routes', {}).get('empirical_data', {}).get('empirical_count', 0)
        
        status['operational_metrics'] = {
            'ais_vessels_active': ais_vessels,
            'empirical_routes_verified': empirical_count,
            'simulation_available': SIMULATION_AVAILABLE
        }
        
        # Overall health
        status['health'] = 'healthy' if ais_vessels > 0 or empirical_count > 0 else 'degraded'
        
        return jsonify(status)
        
    except Exception as e:
        logger.error(f"System status error: {e}")
        return jsonify({
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

# ============================================================================
# SIMULATION API ENDPOINTS
# ============================================================================

@maritime_bp.route('/api/simulation/status')
def simulation_status():
    """
    Get current simulation status.
    """
    try:
        if not SIMULATION_AVAILABLE:
            return jsonify({
                'error': 'Simulation not available',
                'timestamp': datetime.now().isoformat()
            }), 503
        
        # Update simulation
        bergen_simulator.update()
        
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'simulation': bergen_simulator.to_dict(),
            'available': True
        })
    except Exception as e:
        logger.error(f"Simulation status error: {e}")
        return jsonify({
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@maritime_bp.route('/api/simulation/decision', methods=['POST'])
def record_decision():
    """
    Record operator decision.
    """
    try:
        if not SIMULATION_AVAILABLE:
            return jsonify({
                'error': 'Simulation not available',
                'timestamp': datetime.now().isoformat()
            }), 503
        
        data = request.json
        
        decision = bergen_simulator.record_operator_decision(
            operator_id=data.get('operator_id', 'test_operator'),
            decision_type=data.get('decision_type', 'speed_change'),
            decision_data=data.get('decision_data', {}),
            context=data.get('context', {}),
            notes=data.get('notes', '')
        )
        
        return jsonify({
            'success': True,
            'decision': decision,
            'total_decisions': len(bergen_simulator.operator_decisions)
        })
    except Exception as e:
        logger.error(f"Decision recording error: {e}")
        return jsonify({'error': str(e)}), 500

@maritime_bp.route('/api/simulation/alerts')
def simulation_alerts():
    """
    Get simulation alerts.
    """
    try:
        if not SIMULATION_AVAILABLE:
            return jsonify({
                'error': 'Simulation not available',
                'timestamp': datetime.now().isoformat()
            }), 503
        
        # Check for alerts
        bergen_simulator.check_alerts()
        
        return jsonify({
            'timestamp': datetime.now().isoformat(),
            'alerts': bergen_simulator.alerts,
            'position': bergen_simulator.position,
            'total_alerts': len(bergen_simulator.alerts)
        })
    except Exception as e:
        logger.error(f"Alerts error: {e}")
        return jsonify({'error': str(e)}), 500

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def _create_weather_fallback(reason: str):
    """
    Create fallback weather data.
    """
    fallback_data = {
        'temperature_c': 8.5,
        'temperature_display': '8.5°C',
        'wind_speed_ms': 5.2,
        'wind_display': '5.2 m/s',
        'wind_direction_deg': 315,
        'wind_direction': 'NW',
        'city': 'Bergen',
        'data_source': 'fallback',
        'timestamp': datetime.now().isoformat(),
        'fallback_reason': reason
    }
    
    return jsonify(fallback_data)

def _create_alerts_fallback(reason: str):
    """
    Create fallback alerts data.
    """
    fallback_data = {
        'timestamp': datetime.now().isoformat(),
        'total_alerts': 0,
        'priority_counts': {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0},
        'alerts': [],
        'service_status': {
            'service': 'FallbackAlertsService',
            'status': 'unavailable',
            'fallback_reason': reason
        }
    }
    
    return jsonify(fallback_data)

def _degrees_to_direction(degrees):
    """Convert degrees to compass direction."""
    if degrees is None:
        return 'NW'
    
    try:
        deg = float(degrees)
        directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
                     'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW']
        idx = round(deg / 22.5) % 16
        return directions[idx]
    except:
        return 'NW'

def _get_norwegian_city_proximity(lat: float, lon: float, max_distance_km: float = 100):
    """
    Calculate proximity to Norwegian cities.
    """
    norwegian_cities = {
        'Bergen': {'lat': 60.3913, 'lon': 5.3221},
        'Oslo': {'lat': 59.9139, 'lon': 10.7522},
        'Stavanger': {'lat': 58.9699, 'lon': 5.7331},
        'Trondheim': {'lat': 63.4305, 'lon': 10.3951},
        'Ålesund': {'lat': 62.4722, 'lon': 6.1497},
        'Åndalsnes': {'lat': 62.5675, 'lon': 7.6870},
        'Kristiansand': {'lat': 58.1467, 'lon': 7.9958},
        'Drammen': {'lat': 59.7441, 'lon': 10.2045},
        'Sandefjord': {'lat': 59.1312, 'lon': 10.2167},
        'Flekkefjord': {'lat': 58.2970, 'lon': 6.6605}
    }
    
    proximities = []
    for city_name, city_coords in norwegian_cities.items():
        distance = _calculate_distance_km(lat, lon, city_coords['lat'], city_coords['lon'])
        if distance <= max_distance_km:
            proximities.append({
                'city': city_name,
                'distance_km': round(distance, 2),
                'coordinates': city_coords
            })
    
    # Sort by distance
    proximities.sort(key=lambda x: x['distance_km'])
    
    return {
        'nearest_city': proximities[0]['city'] if proximities else None,
        'nearest_distance_km': proximities[0]['distance_km'] if proximities else None,
        'all_proximities': proximities[:3]
    }

def _calculate_distance_km(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """
    Calculate distance between two coordinates in kilometers.
    """
    R = 6371.0
    
    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)
    
    dlat = lat2_rad - lat1_rad
    dlon = lon2_rad - lon1_rad
    
    a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    
    return R * c

# ============================================================================
# END OF FILE
# ============================================================================